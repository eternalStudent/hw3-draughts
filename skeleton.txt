LinkedList.h:
	struct ListNode
		void* data
		struct listNode* next
	struct LinkedList
		int length
		struct listNode* first
		struct listNode* last
		(void*)->() freeFunc

	struct LinkedList* LinkedList_new( (void*)->() );
	int LinkedList_add(struct LinkedList*, struct ListNode*)
	int LinkedList_length(struct LinkedList*)
	int LinkedList_free(struct LinkedList*)

LinkedList.c:
	include LinkedList.h

	static ListNode_new(void*)

Iterator.h:
	include LinkedList.c

	struct Iterator
		ListNode first
		listNode currnet

	struct Iterator* Iterator_new(struct LinkedList* list)
	void* Iterator_next(struct Iterator*)
	int Iterator_hasNext(struct Iterator*)
	void Iterator_free(struct Iterator*)

Tile.h:
	struct Tile
		char x
		int y

	struct Point* Point_new(int, char)
	void Point_print(struct Point*)
	void Point_free(void*)

Tile.c:
	include Tile.h

PossibleMove.h:
	include Tile.c

	struct PossibleMove
		struct Tile* start
		struct LinkedList* moves
		char[][] board

	struct PossibleMove* PossibleMove_new(struct Point*, struct LinkedList*, char[][])
	void PossibleMove_print(struct PossibleMove*)
	void PossibleMove_free(void*)

PossibleMove.c:
	include PossibleMove.h

Board.h:
	include Iterator.c
	include PossibleMove.c

	define Board_WHITE_MAN
	define Board_WHITE_KING
	define Board_BLACK_MAN
	define Board_BLACK_KING
	define Board_EMPTY 
	define Board_SIZE

	void Board_init(char**)
	void Board_clear(char**)
	void Board_copy(char**, char**)
	int Board_set(char**, char, int, char)
	int Board_remove(char**, char, int)
	int Board_move(char**, char, int, char, int)
	struct LinkedList* Board_getPossibleMoves(char**, int)
	char** Board_getPossibleBoard(char**, struct PossibleMove*)
	int Board_getScore(char**) 
	void Board_print(char**)

Board.c:
	include Board.h
	
	static int Board_charToInt(char)
	static int isInRange(int, int);

draughts.c:
	include Board.c

	define BLACK 0
	define WHITE 1

bestMove = minimax(Board_getPossibleMoves(board, AI), maxRecursionLevel, AI);

struct PossibleMove minimax(struct PossibleMove* possibleMove, depth, player){
	if (depth == 0){
		return possibleMove;
	}
	struct LinkedList* possibleMoves = Board_getPossibleMoves(possibleMove->board, player);
	struct possibleMove* bestMove;
	int extremum = 101;
	struct Iterator* iterator = Iterator_new(possibleMoves);
	while (Iterator_hasNext(iterator)) {
		struct PossibleMove* currentPossibleMove = Iterator_next(iterator); 
		int score = Board_getScore( minimax(currentPossibleMove, !player, depth-1) ); 
		if (extremum == 101 || player == BLACK && score>extremum || player == WHITE && score<extremum || isRandom() && score == extremum){
			extremum = value;
			bestMove = currentPossibleMove;
		}
		currentPossibleMove = possibleMoveList_next(possibleMoves);
	}
	return bestPossibleMove;
}